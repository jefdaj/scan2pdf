#!/usr/bin/python3

import os
import sys
import subprocess
from glob import glob
from string import ascii_lowercase
import random
import argparse
import tempfile

### temp file management ###

def prefix(length=6):
    'generates a unique prefix for temp files'
    script = sys.argv[0]
    script = os.path.basename(script)
    script = os.path.splitext(script)[0]
    prefix = [random.choice(ascii_lowercase) for n in range(length)]
    prefix = ''.join(prefix)
    return '%s_%s' % (script, prefix)

def available(prefix='scan', num=1):
    'generates an available filename starting with the prefix'
    candidate = path(prefix, suffix=None, page=num, directory='.')
    if len(glob('%s*' % candidate)) == 0:
        return candidate
    else:
        return available(prefix, num+1)

def path(prefix, suffix='*', page=None, side=None,
         directory=tempfile.gettempdir()):
    'generates a filename with the given characteristics'
    path = [os.path.join(directory, prefix)]
    if page is not None:
        path += '%.2d' % page
    if side is not None:
        path += side
    if suffix is not None:
        path += suffix
    return ''.join(path)

def rm(prefixes, **args):
    'deletes temp files starting with any of the prefixes'
    cmd = ['rm']
    for prefix in prefixes:
        pattern = path(prefix)
        cmd += glob(pattern)
    run(cmd, **args)
 
### pipeline management ###

def run(cmd, **args):
    'runs a command and reports any errors'
    if args['verbose']:
        print(' '.join(cmd))
        subprocess.check_call(cmd)
    else:
        with open(os.devnull, 'wb') as null:
            subprocess.check_call(cmd, stdout=null, stderr=null)

def chain(*commands, **args):
    'chains commands together using temp file prefixes'
    pres = [prefix() for n in range( len(commands)-1 )]
    try:
        commands[0](pres[0], **args)
        for n in range(1, len(commands)-1):
            commands[n](pres[n-1], pres[n], **args)
        commands[-1](pres[-1], **args)
    except:
        raise
    finally:
        rm(pres, **args)

### pipeline commands ###

def scanimage(prefix, suffix='', reverse=False, **args):
    'scans images into pnm files in the current folder'
    if args['duplex']:
        # scan twice, naming files so they alternate
        args['duplex'] = False
        scanimage(prefix, suffix='a', reverse=False, **args)
        input('Put papers back upside down and press ENTER')
        pattern = path(prefix, '*.pnm')
        args['pages'] = len(glob(pattern))
        scanimage(prefix, suffix='b', reverse=True, **args)
    else:
        # scan once
        pattern = '%%02d%s.pnm' % suffix
        filename = path(prefix, pattern)
        cmd = [ 'scanimage'
              , '-x', str(args['width'])
              , '-y', str(args['height'])
              , '--batch=%s' % filename
              , '--source=%s' % args['source']
              , '--format=pnm'
              , '--resolution', '%s' % args['resolution']
              , '--batch-count=%s'   % args['pages']
              , '--mode', args['mode']
              ]
        if reverse:
            cmd += ['--batch-start', str(args['pages'])]
            cmd += ['--batch-increment', '-1']
        if args['verbose']:
            cmd.append('--progress')
        try:
            run(cmd, **args)
        except subprocess.CalledProcessError as e:
            if args['pages'] == -1 and e.returncode == 7:
                # ADF out of paper
                return
            else:
                print(e)
                raise

def pamfix(in_prefix, out_prefix, **args):
    'fixes the truncated pnm files generated by some scanners'
    # see bottom of https://answers.launchpad.net/hplip/+question/229056
    infiles  = glob(path(in_prefix, '*.pnm'))
    for infile in infiles:
        outfile = infile.replace(in_prefix, out_prefix)
        cmd = ['pamfix', '-truncate', infile]
        if args['verbose']:
            cmd.append('-v')
        with open(os.devnull, 'wb') as null:
            with open(outfile, 'wb') as outhandle:
                subprocess.check_call(cmd, stdout=outhandle, stderr=null)

def convert(in_prefix, out_prefix, **args):
    'combines multiple pnm files into a pdf'
    infiles = sorted(glob(path(in_prefix, '*.pnm')))
    outfile = path(out_prefix, '.pdf')
    cmd = ['convert']
    if args['verbose']:
        cmd.append('-verbose')
    cmd += infiles + ['-rotate', '-90', outfile]
    run(cmd, **args)

def mv(in_prefix, **args):
    'moves the finished pdf to the current directory'
    in_filenames = glob(path(in_prefix))
    out_filename = path(args['name'], suffix='.pdf', directory='.')
    assert len(in_filenames) == 1
    cmd = ['mv'] + in_filenames + [out_filename]
    run(cmd, **args)

def xdg_open(**args):
    'opens the finished pdf'
    if not args['open']:
        return
    filename = path(args['name'], suffix='.pdf', directory='.')
    cmd = ['xdg-open', filename]
    run(cmd, **args)

### command line interface ###

def parse(given):
    'parses command line argments into a dict'
    expected = \
        [ ('-n', '--name'      , {'default':'scan'         })
        , ('-s', '--source'    , {'default':'ADF'          })
        , ('-m', '--mode'      , {'default':'color'        })
        , ('-d', '--duplex'    , {'action':'store_true'    })
        , ('-v', '--verbose'   , {'action':'store_true'    })
        , ('-o', '--open'      , {'action':'store_true'    })
        , ('-p', '--pages'     , {'type':int, 'default': -1})
        , ('-r', '--resolution', {'type':int, 'default':300})
        , ('-x', '--width'     , {'type':int, 'default':215})
        , ('-y', '--height'    , {'type':int, 'default':275})
        ]
    parser = argparse.ArgumentParser()
    for arg in expected:
        parser.add_argument(*arg[:-1], **arg[-1])
    parsed = parser.parse_args(given)
    parsed.name = available(parsed.name)
    return parsed.__dict__

def main(args_raw):
    cmds = [scanimage, pamfix, convert, mv]
    args = parse(args_raw)
    chain(*cmds, **args)
    xdg_open(**args)
